---
const { env } = Astro.locals.runtime;

// export const prerender = true;
import '../styles/_global.scss';
import '@fontsource/material-symbols-rounded';
---

<html class="has-navbar-fixed-top">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tidrapportering</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body>
    <section class="section content">
      <div class="container is-max-desktop" x-data="app">
        <template x-if="listView">
          <div>
            <h2>Cats</h2>
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Age</th>
                  <th>Gender</th>
                  <th>&nbsp;</th>
                </tr>
              </thead>
              <tbody>
                <template x-for="catOb in cats">
                  <tr>
                    <td x-text="catOb.name"></td>
                    <td x-text="catOb.age"></td>
                    <td x-text="catOb.gender"></td>
                    <td>
                      <a class="material-symbols-rounded is-size-3" @click="editCat(catOb.id)">edit_square</a>
                      <a class="material-symbols-rounded is-size-3" @click="deleteCat(catOb.id)">delete</a>
                    </td>
                  </tr>
                </template>
              </tbody>
            </table>
            <p>
              <button @click="addCat">Add Cat</button>
            </p>
          </div>
        </template>
        <template x-if="editView">
          <div>
            <h2>Edit Cat</h2>
            <form>
              <label for="name">Name</label>
              <input id="name" x-model="cat.name" />
              <label for="age">Age</label>
              <input id="age" x-model.number="cat.age" />
              <label for="gender">Gender</label>
              <select x-model="cat.gender">
                <option value="male">male</option>
                <option value="female">female</option>
              </select>
            </form>
            <button @click="cancel">Cancel</button>
            <button @click="saveCat">Save</button>
          </div>
        </template>
      </div>
    </section>
    <script>
      document.addEventListener('alpine:init', () => {
        Alpine.data('app', () => ({
          "editView":false,
          "listView":true,
          "cats":[],
          "cat":{
            "id":"",
            "name":"",
            "age":"",
            "gender":""
          },
          async init() {
            await this.readCats();
          },
          cancel() {
            this.setView('list');
          },
          async deleteCat(id) {
            if(!confirm("Are you sure?")) return;
            await deleteCat(id);
            await this.readCats();
          },
          async editCat(id) {
            console.log('edit', id);
            this.cat = await getCat(id);
            this.setView("edit");
          },
          async readCats() {
            this.cats = await getCats();
          },
          async saveCat() {
            /*
            we can gather data, and it is ok if ID is blank, as
            the 'backend' will figure it out
            */
            let editedCat = {
              id:this.cat.id,
              name:this.cat.name,
              age:this.cat.age,
              gender:this.cat.gender
            };

            await persistCat(editedCat);
            // restore our cat ob to blank
            this.cat = {
              id:"",
              name:"",
              age:"",
              gender:""
            };
            this.setView('list');
          },
          addCat() {
            this.setView('edit');
          },
          setView(v) {
            if(v === 'edit') {
              this.listView = false;
              this.editView = true;
            } else {
              this.listView = true;
              this.editView = false;
            }
          }
        }))
      });

      // These methods emulate our backend, beginning with an initial set of static data
      let cats = [
        {"id":1, "name":"Fluffy", "age":4, "gender":"male"},
        {"id":2, "name":"Cracker", "age":8, "gender":"male"},
        {"id":3, "name":"Luna", "age":13, "gender":"female"},
        {"id":4, "name":"Elise", "age":12, "gender":"female"},
        {"id":5, "name":"Grace", "age":14, "gender":"female"},
        {"id":6, "name":"Pig", "age":11, "gender":"female"},
        {"id":7, "name":"Zelda", "age":1, "gender":"female"},
        {"id":8, "name":"Wednesday", "age":1, "gender":"female"},
        ];

        env.NAMESPACE.list();

      async function getCats() {
        return cats;
      }

      async function deleteCat(id) {
        cats = cats.filter(c => c.id !== id);
      }

      async function getCat(id) {
        return cats.filter(c => c.id === id)[0];
      }

      async function persistCat(c) {
        console.log('persistCat', c);
        if(c.id !== '') {
          for(let i=0; i<cats.length;i++) {
            if(cats[i].id === c.id) {
              cats[i] = c;
            }
          }
        } else {
          // make a new id
          let newId = cats.reduce((prev, cur) => {
            if(cur.id >= prev) return cur.id + 1;
            return prev;
          },0);
          c.id = newId;
          cats.push(c);
        }
      }
    </script>
  </body>
</html>
